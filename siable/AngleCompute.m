% ------------------------------------------------------------------------
%
%  Author: LI Zexian
%
% ------------------------------------------------------------------------


function convertedAngles = AngleCompute( ctrl_type, NormOrPhase, is_real_leaves )
    % Compute the Rotation Y angles "convertedAngle" by the Rotation Y binary tree
    if nargin <= 2
        is_real_leaves = false;
    end

    if strcmp( ctrl_type, 'RY' )
        
        if is_real_leaves
            [SumSquareRootAmplitude, Varphi] = positive_transform( NormOrPhase ) ;
        else
            [SumSquareRootAmplitude, Varphi] = AngleSearchBinTree( NormOrPhase );
        end
        while length(SumSquareRootAmplitude) ~= 1
            [SumSquareRootAmplitude, Varphi_list] = AngleSearchBinTree( SumSquareRootAmplitude ) ;
            Varphi = [Varphi_list, Varphi] ;
        end
        convertedAngles = Varphi'.*2 ; 
        %convertedAngles = mod( (Varphi').*2, 4*pi ) ;

    % Compute the Rotation Z angles "convertedAngle" by the Rotation Z binary tree
    elseif strcmp( ctrl_type, 'RZ' )

        InverseM = GenerateInversePhaseMatrix(length(NormOrPhase)) ;
        convertedAngles = InverseM * NormOrPhase ;
        %convertedAngles = mod(convertedAngles, 4*pi) ;
    end
end

%% compute Rotation Y angles from the leaves in a binary tree and updating the the leaves
function [SumSquareRootAmplitude, Varphi_list] = AngleSearchBinTree( amplitude )
% Compute the rotation theta list from the leaves
% Input: a real vector "amplitude"  (Note that the length of "amplitude" have to be 2^n)
% 
% Rotation Y binary tree:
%                                        1
%                       /                                       \
%                *cos(Varphi_1)                             *sin(Varphi_1) 
%               /           \                              /           \
%     *cos(Varphi_2)        *sin(Varphi_2)        *cos(Varphi_3)         *sin(Varphi_3)
%     =:amplitude_norm(1)  =:amplitude_norm(2)  =:amplitude_norm(3)   =:amplitude_norm(4)
% ------------------------------------------------------------------------
    lengthAmplitude = length(amplitude);    
    if lengthAmplitude == 2
        % whose childern is leaf note
        if all(amplitude == 0)
            SumSquareRootAmplitude = 0;
            Varphi_list = 0;
        else
            SumSquareRootAmplitude = sqrt(amplitude(1)^2+amplitude(2)^2) ;
            Varphi_list = acos(amplitude(1)/SumSquareRootAmplitude) ;
        end
    else
        [SumSquareAmplitude1, Theta_list1] = AngleSearchBinTree( amplitude(1:lengthAmplitude/2) );
        [SumSquareAmplitude2, Theta_list2] = AngleSearchBinTree( amplitude(lengthAmplitude/2+1:lengthAmplitude) );
        SumSquareRootAmplitude = [SumSquareAmplitude1,SumSquareAmplitude2];
        Varphi_list = [Theta_list1, Theta_list2];
    end
end


%% Generate the matrix to compute Rotation Z angles
function [InverseM] = GenerateInversePhaseMatrix(N)
% Generate the phase calculation matrix M_k such that [theta] = M_k[hat_theta]
% M_k is the matrix generated by bianry tree.
% input: 'N' a interger of N = 2^n and N=k
% 
% Rotation Z binary tree:
%                           -\hat{\theta_1}/2
%                   /                                 \
%         -\hat{\theta_2}/2                      +\hat{\theta_2}/2 
%               /       \                         /             \
%  -\hat{\theta_3}/2  +\hat{\theta_3}/2  -\hat{\theta_4}/2  +\hat{\theta_4}/2 
%         =:\theta_1    =:\theta_2           =:\theta_3       =:\theta_4
%      
%  [\theta_0;\theta_1;\theta_2;\theta_3] = M_4 [\hat{\theta_0};\hat{\theta_1};\hat{\theta_2};\hat{\theta_3}]
%  where M_{2k} = [kron(M_{k},[1;1], kron(eye(k),1/2.*[1;-1])].
%  and InverseM_{2k} = [kron(InverseM_{k},[1,1]./2); kron(eye(2^(k-1)),[-1,1])].
% 
% ------------------------------------------------------------------------
    InverseM = [-1, -1; -1, 1];
    assert(N >= 2) ;
    if N == 2
        return;
    end
    k = 2;
    while k ~= N
        % upper_InverseM = kron(InverseM,[1,1]./2);
        % lower_InverseM = kron(eye(k),[-1,1]);
        % InverseM = [upper_InverseM; lower_InverseM];
        InverseM = [kron(InverseM,[1,1]./2); kron(eye(k),[-1,1])] ;
        k = k * 2;
    end
end

%{
% The matrix to compute Theta
function [M_k] = GeneratePhaseMatrix(N)
% Generate the phase calculation matrix M_k such that [theta] = M_k[hat_theta]
% M_k is the matrix generated by bianry tree.
% Here is the example of generating M_4:
% 
%                           -\hat{\theta_1}/2
%                   /                                 \
%           -\hat{\theta_2}/2                    +\hat{\theta_2}/2 
%               /       \                         /             \
%  -\hat{\theta_3}/2  +\hat{\theta_3}/2  -\hat{\theta_4}/2  +\hat{\theta_4}/2 
%         =:\theta_1    =:\theta_2           =:\theta_3       =:\theta_4
%      
%  [\theta_0;\theta_1;\theta_2;\theta_3] = M_4 [\hat{\theta_0};\hat{\theta_1};\hat{\theta_2};\hat{\theta_3}]
%  where M_{2k} = [kron(M_{k},[1;1], kron(eye(k),1/2.*[1;-1])].
%
% input: 'N' a interger of N = 2^n and N=k
% ------------------------------------------------------------------------
    M_k = 1/2.*[1, 1; 1, -1];
    if N == 2
        M_k = -M_k;
        return;
    end
    k = 2;
    while k ~= N
        M_left = kron(M_k,[1;1]);
        M_right = kron(eye(k),1/2.*[1;-1]);
        M_k = [M_left, M_right];
        k = 2*k;
    end
    M_k = -M_k;
end
%}


function [SumSquareAmplitude, Varphi] = positive_transform( SignedAmplitude )
    N = size( SignedAmplitude, 1 );
    Varphi = zeros(1, N/2);
    SumSquareAmplitude = zeros(1, N/2);
    for i = 1:N/2
        if all( SignedAmplitude( 2*i-1:2*i, 1 ) == 0 )
            SumSquareAmplitude(i) = 0;
            Varphi(i) = 0;
        else
            num = SignedAmplitude( 2*i-1:2*i, 1 ) ;
            SumSquareAmplitude(i) = norm( num, 2 ) ;
            num = num ./ SumSquareAmplitude(i) ;
            complex_num = num(1) + num(2).*1j;
            Varphi(i) = mod( angle(complex_num), 2*pi ) ;
        end
    end
    % Varphi = Varphi .* 2;
end
